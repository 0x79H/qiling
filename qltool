#!/usr/bin/env python3
# 
# Cross Platform and Multi Architecture Advanced Binary Emulation Framework
#

import argparse
import os
import sys
import ast
import pickle
import unicorn

from qiling import Qiling
from qiling.arch.utils import ql_create_assembler
from qiling.debugger.qdb import QlQdb
from qiling.utils import arch_convert
from qiling.const import QL_VERBOSE, QL_ENDIAN, os_map, arch_map, verbose_map
from qiling.__version__ import __version__ as ql_version
from qiling.extensions.coverage import utils as cov_utils
from qiling.extensions import report

# read code from file
def read_file(fname: str):
    with open(fname, "rb") as f:
        content = f.read()

    return content

def __arg_env(argval: str) -> dict:
    if argval:
        if os.path.exists(argval):
            with open(argval, 'rb') as f:
                env = pickle.load(f)
        else:
            env = ast.literal_eval(argval)
    else:
        env = {}

    return env

def __arg_verbose(argval: str) -> QL_VERBOSE:
    return verbose_map[argval]

def handle_code(options):
    if options.format == 'hex':
        if options.input is not None:
            print ("Load HEX from ARGV")
            code = str(options.input).strip("\\\\x").split("x")
            code = "".join(code).strip()
            code =  bytes.fromhex(code)
        elif options.filename is not None:
            print ("Load HEX from FILE")
            code = str(read_file(options.filename)).strip('b\'').strip('\\n')
            code = code.strip('x').split("\\\\x")
            code = "".join(code).strip()
            code = bytes.fromhex(code)
        else:
            print("ERROR: File not found")
            exit(1)

    elif options.format == 'asm':
        print ("Load ASM from FILE")
        assembly = read_file(options.filename)
        archtype = arch_convert(options.arch)

        archendian = {
            'little': QL_ENDIAN.EL,
            'big'   : QL_ENDIAN.EB
        }[options.endian]

        # TODO: Thumb support.
        assembler = ql_create_assembler(archtype, archendian, 0)
        code, _ = assembler.asm(assembly)
        code = bytes(code)

    elif options.format == 'bin':
        print ("Load BIN from FILE")
        if options.filename is None:
            print("ERROR: File not found")
            exit(1)
        code = read_file(options.filename)

    ql = Qiling(
        rootfs=options.rootfs,
        env=options.env,
        code=code,
        ostype=options.os,
        archtype=options.arch,
        bigendian=(options.endian == 'big'),
        verbose=options.verbose,
        profile=options.profile,
        filter=options.filter
    )

    return ql

def handle_run(options):
    effective_argv = []

    # with argv
    if options.filename is not None and options.run_args == []:
        effective_argv = [options.filename] + options.args

    # Without argv
    elif options.filename is None and options.args == [] and options.run_args != []:
        effective_argv = options.run_args

    else:
        print("ERROR: Command error!")
        usage()

    ql = Qiling(
        argv=effective_argv,
        rootfs=options.rootfs,
        env=options.env,
        verbose=options.verbose,
        profile=options.profile,
        console=options.console,
        log_file=options.log_file,
        log_plain=options.log_plain,
        multithread=options.multithread,
        filter=options.filter
    )

    # attach Qdb at entry point
    if options.qdb == True:
        QlQdb(ql, rr=options.rr)
        exit()

    return ql

def version():
    print(f'qltool for Qiling {ql_version}, using Unicorn {unicorn.__version__}')

def usage():
    version()

    print(f"""
    Usage: {__file__} [run|code] OPTIONS

    With code:
        {__file__} code --os linux --arch arm --hex -f examples/codes/linarm32_tcp_reverse_shell.hex
        {__file__} code --os linux --arch x86 --asm -f examples/codes/lin32_execve.asm
        {__file__} code --os linux --arch arm --hex -f examples/codes/linarm32_tcp_reverse_shell.hex --strace

    With binary file:
        {__file__} run -f examples/rootfs/x8664_linux/bin/x8664_hello --rootfs  examples/rootfs/x8664_linux
        {__file__} run -f examples/rootfs/mips32el_linux/bin/mips32el_hello --rootfs examples/rootfs/mips32el_linux

    With binary file and Qdb:
        {__file__} run -f examples/rootfs/mips32el_linux/bin/mips32el_hello --rootfs examples/rootfs/mips32el_linux --qdb
        {__file__} run -f examples/rootfs/mips32el_linux/bin/mips32el_hello --rootfs examples/rootfs/mips32el_linux --qdb --rr

    With binary file and gdbserver:
        {__file__} run -f examples/rootfs/x8664_linux/bin/x8664_hello --gdb 127.0.0.1:9999 --rootfs examples/rootfs/x8664_linux

    nWith binary file and additional argv:
        {__file__} run -f examples/rootfs/x8664_linux/bin/x8664_args --rootfs examples/rootfs/x8664_linux --args test1 test2 test3

    With binary file and various output format:
        {__file__} run -f examples/rootfs/mips32el_linux/bin/mips32el_hello --rootfs examples/rootfs/mips32el_linux --output=disasm
        {__file__} run -f examples/rootfs/mips32el_linux/bin/mips32el_hello --rootfs examples/rootfs/mips32el_linux --strace -e ^open
        {__file__} run -f examples/rootfs/mips32el_linux/bin/mips32el_hello --rootfs examples/rootfs/mips32el_linux --strace -e ^open

    With UEFI file:
        {__file__} run -f examples/rootfs/x8664_efi/bin/TcgPlatformSetupPolicy --rootfs examples/rootfs/x8664_efi --env examples/rootfs/x8664_efi/rom2_nvar.pickel

    With binary file and json output:
        {__file__} run -f examples/rootfs/x86_windows/bin/x86_hello.exe --rootfs  examples/rootfs/x86_windows/ --console False --json
    """)

if __name__ == '__main__':
    # argparse setup
    parser = argparse.ArgumentParser()
    commands = parser.add_subparsers(title='subcommands', description='valid subcommands', help='additional help', dest='subparser_name')

    run_parser = commands.add_parser('run', help = 'run')
    run_parser.add_argument('-f', '--filename', required=False, default=None, metavar="FILE", dest="filename", help="filename")
    run_parser.add_argument('--rootfs', required=True, help='emulated rootfs')
    run_parser.add_argument('--args', required=False, default=[], nargs=argparse.REMAINDER, dest="args", help="args")
    run_parser.add_argument('run_args', default=[], nargs=argparse.REMAINDER)

    code_parser = commands.add_parser('code', help = 'code')
    code_parser.add_argument('-f', '--filename', required=False, metavar="FILE", dest="filename", help="filename")
    code_parser.add_argument('-i', '--input', required=False, metavar="INPUT", dest="input", help='input hex value')
    code_parser.add_argument('--arch', required=True, choices=arch_map.keys())
    code_parser.add_argument('--endian', choices=('little', 'big'), default='little')
    code_parser.add_argument('--os', required=True, choices=os_map.keys())
    code_parser.add_argument('--rootfs', required=False, help='emulated root filesystem, that is where all libraries reside')
    code_parser.add_argument('--format', choices=('asm', 'hex', 'bin'), default='bin', help='input file format')

    if len(sys.argv) < 2:
        usage()
        exit(0)

    if sys.argv[1] == 'run':
        comm_parser = run_parser

    elif sys.argv[1] == 'code':
        comm_parser = code_parser

    elif sys.argv[1] in ('version', '-v', '--version'):
        version()
        exit(0)

    else:
        print("ERROR: Unknown command")
        usage()
        exit(0)

    comm_parser.add_argument('-v', '--verbose', required=False, choices=verbose_map.keys(), default='default', type=__arg_verbose, help='verbosity level')
    comm_parser.add_argument('--env', required=False, metavar="FILE", type=__arg_env, help="Pickle file containing an environment dictionary")
    comm_parser.add_argument('-g', '--gdb', required=False, help='enable gdb server')
    comm_parser.add_argument('--qdb', action='store_true', required=False, help='attach Qdb at entry point, it\'s MIPS, ARM(THUMB) supported only for now')
    comm_parser.add_argument('--rr', action='store_true', required=False, help='switch on record and replay feature in qdb, only works with --qdb')
    comm_parser.add_argument('--profile', required=False, dest='profile', help="Define customized profile")
    comm_parser.add_argument('--console', required=False, default=True, dest='console', help='display in console')
    comm_parser.add_argument('-e', '--filter', metavar="FUNCTION NAME", required=False, dest="filter", default=None, help="Apply regexp for filtering log output.")
    comm_parser.add_argument('--log-file', dest="log_file", help="Write log to a file")
    comm_parser.add_argument('--log-plain', action="store_true", dest="log_plain", help="Don't use color in log output.")
    comm_parser.add_argument('--root', action='store_true', default=False, dest='root', help='Enable sudo required mode')
    comm_parser.add_argument('--debug_stop', action='store_true', default=False, dest='debug_stop', help='Stop running while encounter any error; requires verbose to be set to either "debug" or "dump"')
    comm_parser.add_argument('-m','--multithread', action='store_true', default=False, dest='multithread', help='Run in multithread mode')
    comm_parser.add_argument('--timeout', required=False, type=int, default=0, help='Emulation timeout')
    comm_parser.add_argument('-c', '--coverage-file', required=False, default=None, dest='coverage_file', help='Code coverage file name')
    comm_parser.add_argument('--coverage-format', required=False, default='drcov', dest='coverage_format', choices=cov_utils.factory.formats, help='Code coverage file format')
    comm_parser.add_argument('--json', action='store_true', default=False, dest='json', help='Print a json report of the emulation')
    options = parser.parse_args()

    if options.console == 'False':
        options.console = False
    else:
        options.console = True

    if options.debug_stop and options.verbose not in (QL_VERBOSE.DEBUG, QL_VERBOSE.DUMP):
        print('ERROR: the debug_stop option requires verbose to be set to either "debug" or "dump"')
        usage()

    # ql file setup
    if (options.subparser_name == 'run'):
        ql = handle_run(options)

    # ql code setup
    elif (options.subparser_name == 'code'):
        ql = handle_code(options)

    # ql execute additional options
    if options.gdb is not None:
        ql.debugger = options.gdb

    if options.debug_stop:
        ql.debug_stop = True

    if options.root is not None:
        ql.root = True

    # ql run
    with cov_utils.collect_coverage(ql, options.coverage_format, options.coverage_file):
        ql.run(timeout=options.timeout)

    if options.json:
        print(report.generate_report(ql, pretty_print=True))

    exit(ql.os.exit_code)
